"""
Implementation of the optimal path formulas given in the following paper:

OPTIMAL PATHS FOR A CAR THAT GOES BOTH FORWARDS AND BACKWARDS
J. A. REEDS AND L. A. SHEPP

Inspiration from NathanLTC: https://github.com/nathanlct/reeds-shepp-curves 
"""

import numpy as np
from math import cos, sin, atan2, pi, sqrt
from enum import Enum
from dataclasses import dataclass, replace
from utils.rs_utils import *
from utils.car import SimpleCar
from utils.environment import Environment
from utils.utils import transform, distance

class Turn(Enum):
    LEFT = 1
    RIGHT = -1
    STRAIGHT = 0


class Gear(Enum):
    FORWARD = 1
    BACKWARD = -1


@dataclass(eq=True)
class PathElement:
    lenght: float
    turn: Turn
    gear: Gear

    @classmethod
    def create(cls, lenght: float, turn: Turn, gear: Gear):
        if lenght >= 0:
            return cls(lenght, turn, gear)
        else:
            return cls(-lenght, turn, gear).reverse_gear()

    def __repr__(self):
        s = "{ Turn: " + self.turn.name + "\tGear: " + self.gear.name \
            + "\tdistance: " + str(round(self.lenght, 2)) + " }"
        return s

    def reverse_turn(self):
        turn = Turn(-self.turn.value)
        return replace(self, turn=turn)

    def reverse_gear(self):
        gear = Gear(-self.gear.value)
        return replace(self, gear=gear)

@dataclass
class RSPath():
    def __init__(self, car: SimpleCar):
        self.car = car
        self.r = self.car.l / np.tan(self.car.max_phi)

    def path_length(self, path):
        """
        Returns the combined lenghts of all parts of the path
        """
        return sum([e.lenght for e in path])


    def get_all_paths(self, start, end):
        """
        Return a list of all the paths from start to end generated by the
        12 functions and their variants
        """
        path_fns = [self.path1, self.path2, self.path3, self.path4, self.path5, self.path6, \
                    self.path7, self.path8, self.path9, self.path10, self.path11, self.path12]
        paths = []

        # get coordinates of end in the set of axis where start is (0,0,0)
        x, y, theta = change_of_basis(start, end, self.r )

        for get_path in path_fns:
            # get the four variants for each path type, cf article
            paths.append(get_path(x, y, theta))
            paths.append(self.timeflip(get_path(-x, y, -theta)))
            paths.append(self.reflect(get_path(x, -y, -theta)))
            paths.append(self.reflect(self.timeflip(get_path(-x, -y, theta))))

        # remove path elements that have parameter 0
        for i in range(len(paths)):
            paths[i] = list(filter(lambda e: e.lenght != 0, paths[i]))

        # remove empty paths
        paths = list(filter(None, paths))

        return paths


    def timeflip(self, path):
        """
        Timeflip transform described around the end of the article
        """
        new_path = [e.reverse_gear() for e in path]
        return new_path


    def reflect(self, path):
        """
        Reflect transform described around the end of the article
        """
        new_path = [e.reverse_turn() for e in path]
        return new_path


    def path1(self, x, y, phi):
        """
        Formula 8.1: CSC (same turns)
        """
        path = []

        u, t = cart2polar(x - sin(phi), y - 1 + cos(phi))
        v = M(phi - t)

        path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
        path.append(PathElement.create(u, Turn.STRAIGHT, Gear.FORWARD))
        path.append(PathElement.create(v, Turn.LEFT, Gear.FORWARD))

        return path


    def path2(self, x, y, phi):
        """
        Formula 8.2: CSC (opposite turns)
        """
        phi = M(phi)
        path = []

        rho, pos1 = cart2polar(x + sin(phi), y - 1 - cos(phi))

        if rho * rho >= 4:
            u = sqrt(rho * rho - 4)
            t = M(pos1 + atan2(2, u))
            v = M(t - phi)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.STRAIGHT, Gear.FORWARD))
            path.append(PathElement.create(v, Turn.RIGHT, Gear.FORWARD))


        return path


    def path3(self, x, y, phi):
        """
        Formula 8.3: C|C|C
        """
        path = []

        xi = x - sin(phi)
        eta = y - 1 + cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho <= 4:
            A = np.arccos(rho / 4)
            t = M(theta + pi/2 + A)
            u = M(pi - 2*A)
            v = M(phi - t - u)
            
            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.RIGHT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.LEFT, Gear.FORWARD))

        return path


    def path4(self, x, y, phi):
        """
        Formula 8.4 (1): C|CC
        """
        path = []

        xi = x - sin(phi)
        eta = y - 1 + cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho <= 4:
            A = np.arccos(rho / 4)
            t = M(theta + pi/2 + A)
            u = M(pi - 2*A)
            v = M(t + u - phi)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.RIGHT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.LEFT, Gear.BACKWARD))

        
        return path


    def path5(self, x, y, phi):
        """
        Formula 8.4 (2): CC|C
        """
        path = []

        xi = x - sin(phi)
        eta = y - 1 + cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho <= 4:
            u = np.arccos(1 - rho*rho/8)
           
            if rho > 0:
                A = np.arcsin(2 * sin(u) / rho)
            else:
                A = 0

            t = M(theta + pi/2 - A)
            v = M(t - u - phi)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.RIGHT, Gear.FORWARD))
            path.append(PathElement.create(v, Turn.LEFT, Gear.BACKWARD))

        return path


    def path6(self, x, y, phi):
        """
        Formula 8.7: CCu|CuC
        """
        path = []

        xi = x + sin(phi)
        eta = y - 1 - cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho <= 4:
            if rho <= 2:
                A = np.arccos((rho + 2) / 4)
                t = M(theta + pi/2 + A)
                u = M(A)
                v = M(phi - t + 2*u)
            else:
                A = np.arccos((rho - 2) / 4)
                t = M(theta + pi/2 - A)
                u = M(pi - A)
                v = M(phi - t + 2*u)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.RIGHT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.LEFT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.RIGHT, Gear.BACKWARD))

    
        return path


    def path7(self, x, y, phi):
        """
        Formula 8.8: C|CuCu|C
        """
        path = []

        xi = x + sin(phi)
        eta = y - 1 - cos(phi)
        rho, theta = cart2polar(xi, eta)
        u1 = (20 - rho*rho) / 16

        if rho <= 6 and 0 <= u1 <= 1:
            u = np.arccos(u1)
            if rho > 0:
                A = np.arcsin(2 * sin(u) / rho)
            else:
                A = 0
            t = M(theta + pi/2 + A)
            v = M(t - phi)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.RIGHT, Gear.BACKWARD))
            path.append(PathElement.create(u, Turn.LEFT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.RIGHT, Gear.FORWARD))

        
        return path


    def path8(self, x, y, phi):
        """
        Formula 8.9 (1): C|C[pi/2]SC
        """
        path = []

        xi = x - sin(phi)
        eta = y - 1 + cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho >= 2:
            u = sqrt(rho*rho - 4) - 2
            A = atan2(2, u+2)
            t = M(theta + pi/2 + A)
            v = M(t - phi + pi/2)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(pi/2, Turn.RIGHT, Gear.BACKWARD))
            path.append(PathElement.create(u, Turn.STRAIGHT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.LEFT, Gear.BACKWARD))

        return path


    def path9(self, x, y, phi):
        """
        Formula 8.9 (2): CSC[pi/2]|C
        """
        path = []

        xi = x - sin(phi)
        eta = y - 1 + cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho >= 2:
            u = sqrt(rho*rho - 4) - 2
            A = atan2(u+2, 2)
            t = M(theta + pi/2 - A)
            v = M(t - phi - pi/2)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.STRAIGHT, Gear.FORWARD))
            path.append(PathElement.create(pi/2, Turn.RIGHT, Gear.FORWARD))
            path.append(PathElement.create(v, Turn.LEFT, Gear.BACKWARD))

        
        return path


    def path10(self, x, y, phi):
        """
        Formula 8.10 (1): C|C[pi/2]SC
        """
        path = []

        xi = x + sin(phi)
        eta = y - 1 - cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho >= 2:
            t = M(theta + pi/2)
            u = rho - 2
            v = M(phi - t - pi/2)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(pi/2, Turn.RIGHT, Gear.BACKWARD))
            path.append(PathElement.create(u, Turn.STRAIGHT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.RIGHT, Gear.BACKWARD))

        
        return path


    def path11(self, x, y, phi):
        """
        Formula 8.10 (2): CSC[pi/2]|C
        """
        path = []

        xi = x + sin(phi)
        eta = y - 1 - cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho >= 2:
            t = M(theta)
            u = rho - 2
            v = M(phi - t - pi/2)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(u, Turn.STRAIGHT, Gear.FORWARD))
            path.append(PathElement.create(pi/2, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(v, Turn.RIGHT, Gear.BACKWARD))

        
        return path


    def path12(self, x, y, phi):
        """
        Formula 8.11: C|C[pi/2]SC[pi/2]|C
        """
        path = []

        xi = x + sin(phi)
        eta = y - 1 - cos(phi)
        rho, theta = cart2polar(xi, eta)

        if rho >= 4:
            u = sqrt(rho*rho - 4) - 4
            A = atan2(2, u+4)
            t = M(theta + pi/2 + A)
            v = M(t - phi)

            path.append(PathElement.create(t, Turn.LEFT, Gear.FORWARD))
            path.append(PathElement.create(pi/2, Turn.RIGHT, Gear.BACKWARD))
            path.append(PathElement.create(u, Turn.STRAIGHT, Gear.BACKWARD))
            path.append(PathElement.create(pi/2, Turn.LEFT, Gear.BACKWARD))
            path.append(PathElement.create(v, Turn.RIGHT, Gear.FORWARD))

        
        return path
    
    def get_route(self, path : list, start):        
        
        phi_list :list= []
        goal_list :list= []
        gear_list :list= []
        pose = [0,0,0]
        
        for e in path:
            phi_list.append(e.turn.value*self.car.max_phi)
            gear_list.append(e.gear.value)
            if e.turn.value == 0:
                theta = pose[2]
                
                x = e.gear.value*e.lenght
               
                pose[0] = pose[0]+x*cos(theta)
                pose[1] = pose[1]+x*sin(theta)
            else:
                theta = pose[2]
                
                x = sin(e.gear.value*e.lenght)
                y = e.turn.value-cos(e.lenght+pi/2-e.turn.value*pi/2)           

                pose[0]=pose[0]+cos(theta)*x-sin(theta)*y
                pose[1]=pose[1]+sin(theta)*x+cos(theta)*y

                pose[2] = M(theta + e.gear.value*e.turn.value*e.lenght)
            
            goal_list.append(pose[:])
        
        goal_list = [revert_change_of_basis(start,g,self.r) for g in goal_list]

        return list(zip(goal_list, phi_list, gear_list))


    def get_best_path(self, start, end):
        """
        Return the shortest non-blocked path from start to end among those that exist
        """
        solutions  = self.get_all_paths(start, end)
        solutions = [s for s in solutions if s is not None]
        solutions.sort(key=self.path_length)

        if not solutions:
            return None, None, False
        
        lenght = None
        
        for s in solutions:
            route = self.get_route(s,start)
            current = start
            safe = True
            for i in range(len(route)):
    
                if route[i][1] == 0:
                    safe = self.is_straight_route_safe(current,route[i][0])
                    current = route[i][0]

                
                if route[i][1] != 0:
                    x = current[0]
                    y = current[1]
                    theta = current[2]
                    circ_center = [x-s[i].turn.value*self.r*sin(theta),y+s[i].turn.value*cos(theta)*self.r]
                    
                    if route[i][2] < 0:           
                        safe = self.is_turning_route_safe(route[i][0], current, np.sign(route[i][1]), circ_center, self.r)
                    else:
                        safe = self.is_turning_route_safe(current, route[i][0], np.sign(route[i][1]), circ_center, self.r)
                    current = route[i][0]
                    
                if not safe:
                    
                    break
            
            if safe:
                lenght = self.path_length(s)*self.r
                break

        return route, lenght, safe
        

    def is_straight_route_safe(self, pos1, pos2) -> bool:
        """ Check a straight route is safe. """
        # a straight route is simply a rectangle

        vertex1 = self.car.get_car_bounding(pos1)
        vertex2 = self.car.get_car_bounding(pos2)

        vertex = [vertex2[0], vertex2[1], vertex1[3], vertex1[2]]

        return self.car.env.rectangle_safe(vertex)
    
    def is_turning_route_safe(self, start_pos, end_pos, d, c, r):
        """ Check if a turning route is safe. """
        # a turning_route is decomposed into:
        #   1. start_pos (checked previously as end_pos)
        #   2. end_pos
        #   3. inner ringsector
        #   4. outer ringsector

        if not self.car.is_pos_safe(end_pos):
            return False
        
        rs_inner, rs_outer = self.construct_ringsectors(start_pos, end_pos, d, c, r)
        
        if not self.car.env.ringsector_safe(rs_inner):
            return False
        
        if not self.car.env.ringsector_safe(rs_outer):
            return False

        return True
    
    def construct_ringsectors(self, start_pos, end_pos, d, c, r):
        """ Construct inner and outer ringsectors of a turning route. """
        
        x, y, theta = start_pos

        delta_theta = end_pos[2] - theta

        p_inner = start_pos[:2]
        id = 1 if d == -1 else 2
        p_outer = transform(x, y, 1.3*self.car.l, 0.4*self.car.l, theta, id)

        r_inner = r - self.car.carw / 2
        r_outer = distance(p_outer, c)

        v_inner = [p_inner[0]-c[0], p_inner[1]-c[1]]
        v_outer = [p_outer[0]-c[0], p_outer[1]-c[1]]

        if d == -1:
            end_inner = atan2(v_inner[1], v_inner[0]) % (2*pi)
            start_inner = (end_inner + delta_theta) % (2*pi)

            end_outer = atan2(v_outer[1], v_outer[0]) % (2*pi)
            start_outer = (end_outer + delta_theta) % (2*pi)
        
        if d == 1:
            start_inner = atan2(v_inner[1], v_inner[0]) % (2*pi)
            end_inner = (start_inner + delta_theta) % (2*pi)

            start_outer = atan2(v_outer[1], v_outer[0]) % (2*pi)
            end_outer = (start_outer + delta_theta) % (2*pi)
        
        rs_inner = [c[0], c[1], r_inner, r, start_inner, end_inner]
        rs_outer = [c[0], c[1], r, r_outer, start_outer, end_outer]

        return rs_inner, rs_outer
    
